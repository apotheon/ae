= Subjunctives

Okay. I can hear the BDDers rumbling, "where's the 'should'?"
Well, AE has nothing against 'should', but there are different
approaches for utilizing should-nomenclature in specifications,
and AE wants to be open to these techniques. One of which
it the way Shoulda (http://shoulda.rubyforge.org) utilizes
+#should+ in a way analogous to RSpec's use of +#it+.

Even so, AE provides a variant subclass of Assertor called
Assertor::Subjunctive. This is an optional class which can be used
to create assertor methods using English-based subjunctive terms
such as +should+, or +must+, +shall+ and +will+. Whatever you like.
To load this library use:

  require 'ae/subjunctive/assertor'

Then all that is required it to define your subjunctive method for all
objects. For example:

  def will(*args, &block)
    Assertor::Subjunctive.new(self, :backtrace=>caller).be(*args,&block)
  end

It's that easy. Because of their popularity AE provides two such terms,
+should+ and +must+ as optional add-ons out-of-the-box.

  require 'ae/subjunctive/should'
  require 'ae/subjunctive/must'

We will use these two methods interchangeable for the rest of this
demonstration, but to be clear they both work exactly the same way,
and almost exactly like #assert.

To be clear. AE's "endorsed" functionality does not entail subjunctive
forms, or +should+ or +must+ assertor methods. These are simply options
you can load via you demo_helper.rb script, if you prefer or need to
support these nomenclatures.


== Fluent Notation and Antonyms

Like +assert+, +should+ and +must+ can be used as a higher order function.

  4.should == 4
  4.must   == 4

With the antonym of +should!+ (read as "should not") or +shouldnt+, and for
+must+, +must!+ or +wont+.

  4.should!  == 5
  4.shouldnt == 5

  4.must! == 5
  4.wont  == 5


== Be and Indefinite Articles

On occasions where the English readability of the specification is
hindered, #be, #a and #an are equivalent forms.

  StandardError.must.be.raised? do
    unknown_method
  end

  "hi".must.be.an.instance_of?(String)

This is the most significant difference between #assert and these other
terms, since #assert does not have #be, #a or #an defined.


== Block Form

In block form +must+ works much like +assert+. If a block parameter is 
used then the receiver will be passed into the block.

We should also mention that, while probably not very useful, since
the arity of a block can be checked, one can also pass the receiver
into the block as a block argument.

  "hi".must do |s|
    /h/ =~ s
  end


== Verifying Object State

The block notation of the subjunctive form is similar to +assert+, with 
the important exception that the block is is evaluated in the scope of the
receiver via #instance_eval, if no block parameter is designated.
This can be also be used to test the state of an object.

  class X
    attr :a
    def initialize(a); @a = a; end
  end

  x = X.new(4)

  x.must do
    4 == @a
  end

And should it fail...

  Assertion.assert.raised? do
    x.must do
      5 == @a
    end
  end

For some this might seem controversial --to test underlying
implementation. And you will get no argument here, it should be used
thoughtfully, but there are occasions when such validations are
necessary.


== Negation via #not.

The subjunctive can be inverted easily using #not.

  x.must.not do |r|
    r.a == 5
  end


== Lambda Assertions

Passing a lambda to the subjunctive method, will use it as if it were
a block of the method. This allows for a simple way to quickly
create reusable assertions.

  palindrome = lambda{ |x| x == x.reverse }

  "abracarba".must.be.a palindrome

QED.

